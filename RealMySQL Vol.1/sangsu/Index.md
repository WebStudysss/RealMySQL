## 디스크 읽기 방식

데이터베이스 성능을 결정짓는 핵심은 **디스크 I/O**다.

디스크는 메모리에 비해 속도가 수십~수천 배 이상 느리며, 특히 HDD는 랜덤 I/O 성능이 매우 낮아 DB 작업에서 병목이 발생하기 쉽다.

DBMS는 이러한 디스크 한계를 보완하기 위해 **인덱스**를 도입했다.

인덱스를 사용하면 원하는 레코드를 찾기 위해 읽어야 하는 페이지 수(디스크 접근 횟수)를 크게 줄일 수 있다.

오늘날 SSD가 보편화되어 랜덤 I/O 성능이 개선되었지만, 대규모 데이터를 전부 스캔하는 것은 여전히 비효율적이므로 인덱스는 필수적이다.

## 인덱스란?

B+Tree 형태 및 특징 설명

B+Tree 형태의 구조

```java
루트 → 브랜치 → 리프 → 데이터 파일
```

B+Tree란? 데이터를 리프에만 담는 트리구조

관련 링크 : https://zorba91.tistory.com/293

**B+Tree 깊이**

B+Tree 인덱스 키값의 크기와 깊이의 상관관계

InnoDB 키 값이 16바이트로 예시를 들었을 때 하나의 페이지 당 약 585개의 키값을 담을 수 있고, 585 * 585 * 585로 2억개 정도의 키 값을 담을 수 있다.

**선택도(기수성)**

모든 인덱스 키 값 중 유니크한 값의 수를 의미

보편적으로 검색 조건이 중요할 때는 선택도가 높은 값이 인덱스, 정렬이나 그루핑같은 작업을 위해선 선택도가 낮은 컬럼도 인덱스를 고려해볼 만한 컬럼이 될 것이다.

**인덱스 레인지 스캔**

노드의 depth를 깊게 들어가며, 조건에 맞는 리프노드부터 이어져있는 다음 페이지를 쭉 탐색해 최종 조건에 있는 데이터를 발견 시 가져옴

**인덱스 풀 스캔**

인덱스 테이블의 데이터를 활용한다. 하지만 인덱스에 선언된 컬럼 중 첫번째 컬럼이 최초 검색조건이 아닌경우 이에 해당된다.

⇒ ex) index (a, b, c)  —> where b = “” && c = 3 등 a컬럼 미사용

**루스 인덱스 스캔**

인덱스 레인지 스캔과 비슷하게 동작하지만, 특정 컬럼의 동일한 값은 하나만 발견하면 스킵되어 다음 값으로 넘어간다.

ex) where c between “c” and “e”  ⇒ “c” ~ “e”를 찾는건 동일하지만, c컬럼의 최초 값을 하나 발견하면 “d” 값을 찾을 때까지 스킵, 동일한 방식으로 “d”를 하나 찾을 시 이후 d는 스킵하며 “e”를 탐색

이는 group by 또는 max, min 등과 같은 집계함수 사용 시 활용됨

**인덱스 스킵 스캔**

MySQL 8.0부터 생긴 기능

커버링 인덱스(활용 컬럼이 모두 인덱스에 포함)여야만 하며, 중간 중간 인덱스 테이블에서 검색을 건너뛰어가며 결괏값을 수집할 수 있음

ex) `select gender, birth_date from employees where birth_date ≥ ‘1965-02-01’;`
⇒ `where gender F and birth_date ≥ 1965-02-01` + `where gender M and birth_date ≥ 1965-02-01`
값을 구할 때 gender M의 1965-02-01 < birth_date 값을 전부 건너뛸 수 있음

**다중 칼럼 인덱스**

다중 칼럼 인덱스는 인덱스를 선언할 때 여러 칼럼을 같이 넣는 인덱스 방식을 뜻하며, 인덱스가 생성될 때 선언 순서대로 정렬되어 인덱스테이블에 저장된다.

**인덱스의 정렬**

인덱스는 B+Tree형식을 유지하기 위해 기본적으로 정렬되어 있음

+ 8.0 버전부터는 인덱스를 생성할 때 정순 역순을 선택해서 미리 정렬된 테이블을 만들어 둘 수 있게 변경되었다.

**인덱스 스캔 방향**

인덱스 스캔의 정순, 역순할 때 동작은 페이지간에는 양방향 연결이 되어있기 때문에 페이지 내부에서 정방향, 역방향으로 돌아가며 확인할 수 있다.

But!!
내림차순 인덱스를 필요할 때 만들어 두면 좋은 이유가 있다.
내림차순 테이블 스캔 시 역순 데이터를 가져오는 방식은 정순 데이터를 가져오는 방식에 비해 약 30퍼센트 가량 느렸다. 이유는 InnoDB 데이터 저장방식에 있는데, 저장된 데이터는 페이지 기준으로는 양방향이지만, 각 레코드 기준으로는 단방향으로 되어있기 때문이다.

그래서 만약 역순으로 가져오게 된다면 페이지 간 이동할 때마다 

- gpt답변 명확
    
    ## 왜 정순(ASC) 스캔이 보통 더 빠를까?
    
    ### 1) 리드어헤드(read-ahead)·프리페치가 “앞으로”에 맞춰져 있음 (가장 큼)
    
    - InnoDB와 OS의 리드어헤드는 **연속적으로 증가하는 페이지 번호** 접근을 감지해 미리 다음 페이지들을 읽어 둡니다.
    - **역순(DESC)** 으로 내려가면 이 **선형 리드어헤드가 잘 트리거되지 않거나 비효율**적이라, **I/O 대기**가 늘기 쉽습니다.
    - 디스크·파일시스템·스토리지 컨트롤러도 전형적으로 **정방향 순차 읽기**에 최적화되어 있어요.
    
    ### 2) CPU 하드웨어 프리페치·캐시의 방향성
    
    - 같은 16KB 페이지 내부에서도, **오프셋이 증가하는 방향(정순)** 으로 레코드를 따라갈 때 **하드웨어 프리페처가 더 잘 맞아떨어짐** → 캐시 히트율이 좋아짐.
    - 역순은 **포인터 추적 패턴이 덜 예측 가능**하고, 다음에 접근할 캐시라인을 미리 끌어오기가 상대적으로 불리.
    
    ### 3) InnoDB 페이지/레코드 구조의 비대칭성(영향은 ‘있지만’ 상대적으로 작음)
    
    - **페이지 간**: B+Tree 리프 페이지는 `FIL_PAGE_PREV/NEXT`로 **양방향** 연결이라, …10→…6 다음에 **이전 페이지로 가는 것 자체는 O(1)** 로 쉬워요.
    - **페이지 내부 레코드**: 레코드 헤더에 **next 포인터만 있고 prev는 없음(단방향)**.
        - 역순으로 한 레코드씩 “이전”으로 가려면 InnoDB는 **페이지 디렉터리(page directory, 슬롯/n_owned)** 를 써서 뒤쪽 덩어리로 점프한 뒤, **그 그룹 안에서 다시 next 포인터를 따라 역으로 위치를 찾아갑니다.**
        - 즉 **완전한 O(n) 역주행**은 아니지만, **정순(그냥 next만 타면 됨)** 보다 **분기·포인터 추적이 더 복잡**해서 CPU 관점에서 조금 불리합니다.
    - 이 차이는 **I/O 리드어헤드 차이보다는 보통 작지만**, **버퍼 풀에 다 올라온 상태(메모리 히트 100%)** 라면 체감 원인으로 떠오를 수 있어요.
    
    ### 4) 정렬/실행계획 측면의 추가 요소(상황에 따라)
    
    - **MySQL 8.0의 DESC 인덱스**가 없던 시절(또는 해당 열에 DESC 인덱스가 없을 때) `ORDER BY … DESC`는
        - 인덱스 정순 스캔 + 정렬(Using filesort) 또는
        - 전부 읽고 역순 재배열
            
            같은 경로를 타기도 해서 **추가 오버헤드**가 섞일 수 있습니다.
            
    - **클러스터드(프라이머리 키) 전체 스캔** 기준이라면 위의 **리드어헤드/프리페치 비대칭**이 가장 체감되는 부분.
    
    ---
    
    ## 질문에 나온 예(1–5 | 6–10)로 보면
    
    - 10→9→8→7→6 (같은 페이지 안) : **단방향 레코드 구조** 때문에 **이전 레코드를 바로 가리키는 포인터가 없어** 디렉터리/소유 그룹(n_owned)을 참조해 “뒤쪽으로 점프 후 next로 역추적”하는 식의 **추가 단계**가 들어갑니다.
    - 6 이후 **이전 페이지로 이동**: 페이지는 **양방향 링크**라 **이전 페이지 포인터로 바로 점프**할 수 있어요(여기선 큰 부담 없음).
    - 하지만 **그 다음 페이지(1–5)에서 다시 “가장 뒤 레코드”부터 역순으로 읽기**가 필요하고, 이때도 **디렉터리+next 추적**이 계속 들어갑니다.
    - 여기에 **역방향 스캔은 리드어헤드가 약해질 가능성**이 겹치면 체감 속도 차이는 더 커집니다.

**인덱스의 가용성**

- NON-EQUAL
- LIKE 앞부분 %
- 스토어드 함수
- 데이터 타입이 서로 다른 비교
- 문자열 데이터 타입의 콜레이션이 다를 때

**R-Tree 인덱스**

공간 인덱스(Rectangle-Tree)라고 불리우며 공간 관련한 데이터를 활용해서 녹일 수 있다.

**함수 기반 인덱스**

컬럼의 값만 인덱싱 하던 방식이 8.0버전 부터는 함수에 대해서도 미리 인덱싱이 될 수 있도록 지원한다.
ex) `INDEX ix_fullname ((CONCAT(first_name,’ ‘,last_name)))`

**클러스터링 인덱스**

클러스터링 인덱스 키를 적절히 선택해야함

타임소트 가능한 UUID가 절충안이며, 테이블 그 자체이다.

**세컨더리 인덱스**

세컨더리 인덱스의 레코드 저장값은 프라이머리키

**클러스터링 인덱스의 장점과 단점**

클러스터링 인덱스는 기본 키 기준으로 정렬되어 저장하기 때문에 기본키 기반 검색 시 조회 속도가 빠른 것이 특장점이며, 세컨더리 인덱스가 무거운 것이 무거운 편이다.

세컨더리 인덱스가 무거운 이유는 세컨더리 인덱스의 리프 노드에는 클러스터링 인덱스 키가 저장되어있기 때문에 클러스터링 인덱스 키 기준으로 한번 더 레코드를 찾아야 한다.

**유니크인덱스 사용 시 주요사항**

유니크 인덱스의 기본 특성으로, 값의 고유성을 보장해야 하기 때문에 매 레코드 추가마다 해당 인덱스의 고유함을 검증 해야한다. 따라서, 성능이 더 느린 편이다.

애플리케이션 단에서 할까?
라고 했을 땐 또 애플리케이션 보단 db가 보편적으로 더 좋음

**외래키**

외래키 인덱스가 걸리면 반드시 잠금이 발생한다.
