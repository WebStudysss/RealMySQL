# 개요

실행 계획을 이해할 수 있어야 실행 계획의 불합리한 부분을 찾고 최적화를 진행할 수 있다.

## 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정

1. **SQL 파싱** : 요청 받은 SQL 문장을 쪼개서 SQL서버가 이해할 수 있는 수준으로 파싱
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
3. 2단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 받음

### 1단계

- 문법적으로 잘못된 문장은 SQL 파싱 단계에서 걸러짐
- **SQL 파스 트리**가 만들어지는 단계

### 2단계

- SQL 파스 트리를 참조한다
    - 불필요한 조건 제거 및 복잡 연산 단순화
    - 여러 테이블의 조인이 있을 때 어떤 순서로 테이블을 읽을지 결정
    - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
    - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- 최적화 및 실행 계획 수립 단계

### 3단계

- 스토리지 엔진에 레코드를 요청해 작업을 수행한다.
- MySQL 엔진과 스토리지 엔진이 동시 참여

## 옵티마이저의 종류

- 비용 기반 최적화(CBO)
    - 쿼리를 처리하기 위한 여러 방법을 만들고, 각 단위 작업의 비용 정보와 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출 후 최적의 쿼리 순서로 실행
    - MySQL 포함 대부분의 RDBMS가 채택
- 규칙 기반 최적화(RBO)
    - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
    - 사용자의 데이터 분포도가 다양하기에 거의 사용되지 않음

---

# 기본 데이터 처리

### MySQL 서버가 사용하는 알고리즘

- 풀 테이블 스캔
- 풀 인덱스 스캔
- 병렬 처리
- ORDER BY 처리(Using filesort)
- GROUP BY 처리
- DISTINCT 처리
- 내부 임시 테이블 활용

## 풀 테이블 스캔

인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미

- **옵티마이저가 풀 테이블 스캔을 선택하는 기준**
    - 테이블의 레코드 건수가 작을 때
    - WHERE 절이나 ON 절에 적절한 조건이 없는 경우
    - 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
- InnoDB에서는 특정 테이블의 연속된 데이터 페이지가 읽히면 `innodb_read_ahead_threshold` 변수 기준으로 **리드 어헤드**(Read ahead)작업이 자동으로 시작된다
- **리드 어헤드(Read ahead) :** 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 작업
⇒ **쿼리문 처리시 메모리에 있는 데이터 페이지만 체크하면 되므로 성능 향상**
- 풀 인덱스 vs 풀 테이블 예시
    - `SELECT COUNT(*) FROM employees;` → 풀 인덱스 스캔
    - `SELECT * FROM employees;` → 풀 테이블 스캔

## 병렬 처리

MySQL 8.0부터 지원하기 시작한 `쿼리 병렬처리`

- `SET SESSION innodb_parallel_read_threads=1;`
- WHERE 조건 없이 테이블 전체 건수를 가져오는 쿼리만 병렬 처리 가능 (일부 스캔/집계 쿼리에 대해서만)
→ `SELECT COUNT(*) FROM salaries;`

## ORDER BY 처리(Using filesort)

- 정렬 처리 방법은 **인덱스, filesort**
- **인덱스**
    - 장점
        - INSERT, UPDATE, DELETE 쿼리가 실행될 때 순서대로 읽어 자료 처리
    - 단점
        - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업 필요
        - 인덱스를 담아야하는 디스크 공간 추가 필요
        - 인덱스 개수가 늘수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요
- **Filesort**(ExtraMessage : Using filesort)
    - 장점
        - 인덱스를 생성하지 않아도 되기에 디스크 공간 필요x
        - 레코드가 많지 않으면 메모리에서 정렬 처리하기 때문에 빠르다
    - 단점
        - 정렬 작업이 쿼리 실행 시 처리하므로 레코드 건수가 많을수록 응답 속도가 느리다.
        - 메모리에서 정렬하기에 큰 메모리가 사용된다

### 현실적으로 인덱스를 활용하지 못하는 이유

- 정렬 기준이 너무 많아서 요건 별로 인덱스를 생성하는 것이 불가능
- GROUP BY, DISTINCT의 처리결과를 정렬해야하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### 소트 버퍼

MySQL이 정렬을 수행하기 위해 별도의 메모리 공간을 할당받는 **Sort Buffer**

- Session 영역에서 수행하는 메모리
- 정렬 명령 수행 시 동작
- 버퍼의 크기를 초과한다면 임시로 디스크에 저장 후 병합
- 메모리를 무작정 크게한다고 해서 좋은 점이 없다
    - 세션 영역이기에 클라이언트가 많을 수록 빠르게 상승하는 메모리 사용량
    - 실제 벤치마크시 큰 차이를 보이지 않음
    - 혹시나 메모리 부족이 발생했을 시 MySQL이 운영체제에서 제거당함

### 정렬 알고리즘

옵티마이저 트레이스를 통해 쿼리가 어떤 정렬을 사용할지 알 수 있다.

```sql
SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

SELECT * employees ORDER BY last_name LIMIT 100000, 1;
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G
```

- **싱글 패스**
    - `<sort_key, additional_fields>` 한 번에 정렬(메모리↑, 랜덤 I/O↓)
    - 결과 필드가 작거나 건수가 과하지 않을 때 유리.
- **투 패스** - 정렬 키와 레코드 전체를 정렬
    - 투 패스: `<sort_key, rowid>` 정렬 후 테이블 재조회(메모리↓, I/O 한 번 더)
    - 레코드의 크기나 건수가 상당히 많을 때 효율적
- MySQL에서는 일반적으로 싱글패스를 사용하며, 특수한 경우에만 투패스를 사용한다
    - 레코드의 크기가 max_length_for_sort_data 변수값보다 클 때
    - BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

### 정렬 처리 방법

ORDER BY가 사용되었을 때 사용되는 방법, 효율 순서

| 정렬 처리 방법 | 실행 계획의 Extra 칼럼 내용 |
| --- | --- |
| 인덱스를 사용한 정렬 | 별도 표기 없음 |
| 조인에서 드라이빙 테이블만 정렬 | “Using filesort” |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | “Using temporary; Using filesort” |

**옵티마이저의 판단**

1. 인덱스를 활용 가능한지 검토
2. WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장 후 Filesort 처리
    1. 조인의 드라이빙 테이블만 정렬한 후 조인 수행
    2. 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행

### 인덱스를 이용한 정렬

- ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용되면 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
- WHERE절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
- B-Tree 계열의 인덱스가 아닌 인덱스 사용불가(R-Tree포함)
- 여러 테이블이 조인되는 경우 네스티드-루프(Nested-loop) 방식의 조인에서만 사용 가능
    - Nested-loop의 조건이 깨지는 주의사항은 뭘까
- **인덱스는 이미 정렬되어있는 테이블이기 때문에 ORDER BY를 명시한다고 해서 추가 작업이 이루어지지는 않음**

### 조인의 드라이빙 테이블만 정렬

```sql
EXPLAIN select * 
	from employees e, salaries s 
	where s.emp_no=e.emp_no and e.emp_no 
	between 100002 and 100010 
	order by e.last_name;
```

- where절의 검색 조건인 emp_no는 employees의 pk
- 드리븐 테이블(salaries)의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.

### 임시 테이블을 이용한 정렬

```sql
EXPLAIN select * 
	from employees e, salaries s 
	where s.emp_no=e.emp_no and e.emp_no 
	between 100002 and 100010 
	order by s.salary;
```

- ORDER BY의 정렬 기준이 드리븐 테이블

### 정렬 처리 방법의 성능 비교

- ORDER BY나 GROUP BY 같은 경우 LIMIT 처리를 위해서는 모든 레코드 데이터가 필요
- 쿼리의 처리방식에 밀접한 연관
    - 스트리밍 방식
        - 조건에 일치하는 레코드가 검색될 때마다 즉시 클라이언트로 전송하는 방식
        - 일치할 때마다 보내주는 형식이기 때문에 LIMIT의 효율이 좋음
    - 버퍼링 방식
        - ORDER BY, GROUP BY같은 쿼리문이 들어가는 방식
        - ORDER BY, GROUP BY 쿼리문이 실행되기 위해서는 모든 레코드가 필요
        - 인덱스가 활용된 ORDER BY 쿼리문만 이중 유일하게 스트리밍 방식으로 처리

### 정렬 관련 상태 변수

정렬할 때 이루어진 병합작업 횟수 등 로그를 확인하고 싶을 때 활용

```sql
FLUSH STATUS;
SHOW STATUS LIKE 'Sort%';
```

## GROUP BY 처리

- 스트리밍 불가한 쿼리문
- HAVING 절은 필터링 역할
- GROUP BY는 적절한 인덱스를 가지면 정렬과 해시 없이 인덱스 순회만으로 처리 가능
- 작업 형식
    - 인덱스 사용
        - 드라이빙 테이블에 속한 칼럼만 활용될 때 사용가능
        - **인덱스 레인지 스캔**(타이트 인덱스 스캔)
            - 이미 정렬된 인덱스를 읽는 것이므로 Extra 표시 x
        - **루스 인덱스 스캔**
            - 레코드를 건너뛰면서 필요한 부분만 읽어서 가져옴
            - Extra - Using index for group-by
    - 인덱스 미사용
        - 임시 테이블
            - 인덱스를 전혀 사용하지 못할 때 사용되는 방식
            - 8.0에서는 MySQL 자체적으로 임시 테이블을 생성 후 중복체크
            - Extra - Using temporary

## DISTINCT 처리

특정 칼럼의 유니크 값만 조회하려면 SELECT 쿼리에 DISTINCT를 사용하는데, 집합함수 사용 여부에 따라 처리방식이 나뉨

- 집합함수 미사용
    
    ```sql
    8.0 버전부터 동일한 방식으로 실행되는 쿼리문
    SELECT DISTINCT emp_no FROM salaries;
    SELECT emp_no FROM salaries GROUP BY emp_no;
    
    SELECT DISTINCT first_name, last_name FROM employees;
    => first_name, last_name의 조합 전체를 가져옴 약 27만개
    ```
    
- 집합함수 사용
    - 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져옴
    
    ```sql
    SELECT COUNT(first_name, last_name FROM employees;
    ```
    

## 내부 임시 테이블 활용

MySQL이 사용하는 내부 임시 테이블의 기본적인 특징으로는 메모리 영역에서 활동하다 테이블의 크기가 커지면 디스크로 옮겨진다.

### 메모리 임시 테이블과 디스크 임시 테이블

- 8.0이전 MEMORY 엔진
- 8.0이후 메모리는 **TempTable** 스토리지 엔진, 디스크는 InnoDB 스토리지 엔진
- 가변 길이 타입을 지원하는 TempTable 스토리지 엔진
- 트랜잭션을 지원하는 InnoDB 스토리지 엔진이 사용
- 메모리에서 사용중 임시 테이블 크기가 설정 값(`temptable_max_ram`)보다 커지는 경우 디스크 저장방식을 택함
    - MMAP 파일로 기록
        - MMAP파일이 InnoDB 테이블에 기록하는 것보다 오버헤드가 적음
    - InnoDB 테이블로 기록

### 임시 테이블이 필요한 쿼리

아래의 경우 데이터 가공 작업이 필요하기에 임시 테이블을 생성하는 케이스

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY와 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- 인덱스를 사용하지 못할 때
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

보통의 경우 Extra 칼럼에 Using temporary가 표시되고, 아래의 세 종류는 표시되지 않을 때도 임시 테이블을 사용하는 경우가 있고, **DERIVED인 쿼리를 제외하고는 유니크 인덱스가 생성됨**

### 임시 테이블이 디스크에 생성되는 경우

- UNION이나 UNION ALL에서 SELECT되는 칼럼 중 길이가 512바이트 이상인 칼럼
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 칼럼
- 메모리 임시 테이블의 크기가 각 시스템 변수 값보다 큰 경우

### 임시 테이블 관련 상태 변수

임시 테이블이 사용되었는지, 또 어디로 생성되었는지 확인할 때 활용 방법

```sql
FLUSH STATUS;

SELECT first_name, last_name
	FROM employees
	GROUP BY first_name, last_name;

SHOW SESSION STATUS LIKE 'Created_tmp%';
```

---

# 고급 최적화

JDBC의 경우 기본 처리방식 버퍼링 → 대용량일 땐 커스텀해서 스트리밍 방식으로 변경 가능

```java
[MySQL 서버 레이어]                          [스토리지 엔진 (InnoDB)]
───────────────────────────────             ───────────────────────────────
1. 옵티마이저 실행계획 수립
   - 어떤 인덱스 사용할지 결정
   - JOIN 순서, 접근 방식 결정
   ↓

2. 드라이빙 테이블에서 join 키 수집
   - 키들을 버퍼에 모아둠
   - (예: 여러 emp_no, 여러 from_date)
   ↓

3. 수집한 키 정렬
   - PK 순서나 인덱스 순서대로 재정렬
   - "이 순서로 읽으면 순차 접근 가능"
   ↓────────────── 요청 전달 ─────────────→

                                               4. InnoDB가 인덱스(B+Tree) 탐색
                                                  - 서버가 준 키 순서대로 클러스터드 인덱스 접근
                                                  - 랜덤 I/O 대신 순차 I/O 효과
                                               ↓

                                               5. 레코드 반환
                                                  - 필요한 레코드를 서버에 전달
───────────────────────────────             ───────────────────────────────

```

MRR이 없는 네스티드 루프 조인

```java
[서버 레이어]
드라이빙 테이블에서 한 건씩 읽음
 ↓ (키)
 ─────────────→   [스토리지 엔진]
                  PK/B+Tree 탐색
                  (랜덤 I/O)
 ←─────────────
다음 키 ...

```

MRR 적용된 네스티드 루프 조인

```java
[서버 레이어]
1. 드라이빙 테이블에서 여러 키를 모음
   (버퍼링)
2. 키들을 PK 순서대로 정렬
   ↓ (정렬된 키 묶음 전달)
 ─────────────→   [스토리지 엔진]
                  3. 정렬된 키 순서대로
                     B+Tree 순차 탐색
                     (순차 I/O 효율 ↑)
                  4. 레코드 묶음 반환
 ←─────────────
다음 묶음 ...

```

MRR의 특장점. 순차적으로 읽어오고, 버퍼링을 통해 한번에 값을 읽어오기에 랜덤I/O 접근 및 빈도 수가 줄어듦

8.0부터는 코스트 기반으로 자동 적용

단점 : 정렬에 비용이 더 드는 경우가 있다.

- GPT 설명
    
    ```java
    🔹 Block Nested Loop Join (BNL)의 아이디어
    
    “outer row를 하나씩 처리하지 말고 여러 개 묶어서(버퍼링) 처리하자.”
    
    과정:
    
    outer 테이블에서 일정량(row block)을 메모리 조인 버퍼에 적재.
    
    inner 테이블 풀스캔을 한 번만 돌면서, 버퍼에 있는 모든 outer row와 조인 조건을 동시에 비교.
    
    다음 outer block을 가져와서 반복.
    
    이렇게 하면 inner 테이블 풀스캔 횟수를 outer row 개수만큼 하지 않고, outer block 개수만큼만 수행하게 됨.
    ```
    

```java
MySQL에서 조인의 기본 동작

조인은 테이블끼리 연결하기 위한 방식이야.
실제로 연결하는 일은 MySQL 엔진에서 하고, 스토리지 엔진(InnoDB)은 그냥 “조건 맞는 row 가져와” 요청을 처리해줄 뿐이야.

즉 a.row_id = b.row_id로 조인한다고 하면,

드라이빙 테이블 a에서 row를 하나 가져와

그 값으로 드리븐 테이블 b에서 row를 찾고

조건 맞으면 결과로 묶어주고
→ 다음 row로 넘어가는 식으로 동작해.

예를 들면 a.row_id = {1,2,3} 이라면

a.row_id=1 → b에서 row_id=1 찾아서 join

a.row_id=2 → b에서 row_id=2 찾아서 join
… 이렇게 하나하나 반복하는 구조가 Nested Loop Join이야.

MRR (Multi-Range Read)

이 방식의 단점은 뭐냐면, a에서 row를 하나씩 가져올 때마다 b 인덱스를 랜덤하게 lookup 해야 해서 랜덤 I/O가 너무 많아진다는 거야.

그래서 나온 게 MRR이야.
MRR은 단순히 한 건씩 즉시 드리븐 테이블을 조회하지 않고,

드라이빙 테이블에서 가져온 조인 키(row id)를 조인 버퍼에 모아둬

그 키들을 인덱스 순서(PK 순서) 로 정렬해

그리고 InnoDB에 “이 키들 순서대로 찾아와” 하고 요청해

이러면 InnoDB는 인덱스를 순차적으로 스캔할 수 있어서 랜덤 I/O가 줄어들어.
즉, MRR은 MySQL 엔진 ↔ 스토리지 엔진 사이의 상호작용을 최적화하는 기술이야.
(참고로 여기서 정렬은 “드라이빙 테이블 정렬”이 아니라 “조인 키를 PK 순서대로 정렬”하는 거야. 그래서 정렬 비용이 더 들 수도 있어서 기본값은 꺼져 있어.)

BNL (Block Nested Loop)

BNL은 얘기가 조금 달라.
만약 조인 조건이 인덱스를 못 타는 경우가 있어.
예를 들면 a.col1 = b.col1 AND a.col2 + b.col2 > 10 이런 식이면 b.col에 인덱스가 있어도 못 쓰고 결국 b 테이블을 풀스캔해야 하거든.

이때 기본 Nested Loop Join을 쓰면 a의 row마다 b를 매번 풀스캔하게 돼 → 이건 너무 비효율적이지.
그래서 BNL은 a 테이블에서 여러 row(블록)를 메모리 버퍼에 모아두고,
b 테이블 풀스캔을 한 번 돌리면서 그 안에서 버퍼에 있는 a row들과 조건을 동시에 비교해.

즉,

NLJ: a row 1개 → b 풀스캔, a row 2개 → b 또 풀스캔 … (outer row 개수만큼 inner 풀스캔)

BNL: a row 여러 개 모아서 (예: 1000개) → b 풀스캔 한 번 돌려서 다 같이 비교 → outer row 블록 개수만큼만 inner 풀스캔

이렇게 해서 inner 풀스캔 횟수를 확 줄여주는 게 BNL이야.
여기서 중요한 건, “조건이 여러 개라서” BNL을 쓰는 게 아니라, 조건이 인덱스를 못 타서 풀스캔해야 하는 상황이라서 BNL을 쓰는 거야.
즉 ON 절에 조건이 여러 개 들어갔든, WHERE 절에 조건이 있든 상관없이, 인덱스를 못 쓰는 상황이면 BNL이 발동될 수 있는 거지.

정리

조인 자체는 MySQL 엔진에서 row 단위로 비교하는 방식

MRR: 조인 키를 모아서 정렬 → InnoDB가 순차 I/O 하도록 도와줌 (랜덤 I/O 최적화)

BNL: outer row를 블록 단위로 모아서 inner 풀스캔 횟수를 줄임 (풀스캔 최적화)

조건이 여러 개인 게 핵심이 아니라, 인덱스를 못 타는 상황에서 BNL이 의미가 있는 거야.
```

8.0.20부터는 BNL은 사용하지 않고 해시 조인이 사용됨

해시로 대체된 이유

```java
🔹 BNL의 동작 복습

드라이빙 테이블 row들을 메모리 버퍼에 모음

드리븐 테이블을 매번 풀스캔하면서 버퍼 row와 조건 비교

버퍼 크기가 작으면 inner 풀스캔을 여러 번 반복해야 함

👉 즉, BNL은 inner 테이블을 반복적으로 스캔해야 한다는 근본적인 비효율이 있어요.
```

```java
select * from employees e
where e.emp_no IN(select s.emp_no from salaries s where s.salary> 150000);

select e.*
from employees e, salaries s
where e.emp_no=s.emp_no and s.salary> 150000
group by e.emp_no;

```

MYSQl 5.7 버전부터는 이렇게 파생 테이블로 만들어지는 서브 쿼리를 외부 쿼리와 병합해서 서브 쿼리 부분을 제거하는 최적화가 도입되었는데, derived_merge 최적화 옵션은 이러한 임시 테이블 최적화를 활성화할지 여부를 결정한다. 이제 위의 쿼리에서 임시 테이블이 외부 쿼리로 병합된 경우의 실행 계획을 한번 살펴보자.
